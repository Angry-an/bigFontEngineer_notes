/**Virtual DOM
 * 1.就是一个用来轻量化描述dom的JavaScript对象
 * 2. facebook 都用php开发网站，一开始字符串拼接时代。
 *  a.问题：代码写出来难看，还容易造成xxs攻击
 *  b.应对方法：对用户的任何输入都进行转义。缺点：如果又不小心把 HTML 标签（Markup）给转义了，那么 HTML 标签会直接显示给用户，从而导致很差的用户体验
 * 3. xhp时代：为了更加高效的编码，同时也避免转义 HTML 标签的错误，Facebook 开发了 XHP 
 * 4. jsx时代：把 XHP 的拓展功能迁移到 JS 中。可能原因：前后端分离导致的
 * 5. react：这个时候有个很大的问题，dom直接操作太多。代码混乱，难以维护。随后退出了整体刷新页面的思想
 *    当状态发生变化的时候，react自动更新ui。这个时候，我只需要关系我的状态（数据是什么），以及 UI 长什么样（布局），不再需要关系操作细节。
 * 6， 这种方式虽然简单粗暴，但是很明显的缺点，就是很慢。于是推出diff算法：对于没有改变的 DOM 节点，让它保持原样不动，仅仅创建并替换变更过的 DOM 节点。这种方式实现了 DOM 节点复用（Reuse）。
 * 总结：
 *  a. 传统的前端编程方式是命令式编程，直接操作dom，就是告诉浏览器该怎么做。这样存在问题是：大量代码操作dom，可读性低，维护性差。
 *  b. 于是推出了声明式编程。抛弃原有的直接操作dom细节转而改为只关注数据变化，dom操作由框架来完成。从而大幅度提高了代码可读性和可维护性
 *  c. 由于数据变化，页面整体刷新就导致新的问题：性能差，效率低。可能一小部分的变化要导致整个页面的刷新。于是推出了diff算法
 *  d. diff算法（降低复杂度）：将数据变动前后的 DOM 结构先进行比较，找出两者的不同处，然后再对不同之处进行更新渲染。因为dom是很复杂的，对比
 *    起来很麻烦（创建一个空的div。遍历他的会有231个属性）。对于这么多属性，大部分是用不到的。所以采用更轻量级的js对象来代替复杂的dom节点，这个
 *    轻量级js就是虚拟dom。
 *  e. diff过程：
 *        1.维护一个js对象表示虚拟dom，和真实dom一一对应。
 *        2.然后两个虚拟dom做diff，生成变更
 *        3.将变更反应在真实dom上
 *    可以看出最后还是避免不了操作dom。但是diff算法已经将dom改动次数降到最低
 *  f. 最后：虚拟dom和diff算法的出现是为了解决命令式编程转变声明式编程、数据驱动所带来的的性能问题。换句话说就是直接操作dom性能并不低于虚拟dom和diff算法，甚至还优于
 *  扩展：shouldComponentUpdate优化：很多组件实际上是肯定不会发生变化的,这个时候需要用shouldComponentUpdate进行手动操作来减少diff,从而提高程序整体的性能.
 * 问题：一、vue既然知道了哪里发生了变化，为什么还v2.0依然添加了虚拟dom
 *     1. Vue的响应式系统就知道,通常一个绑定一个数据就需要一个Watcher,一但我们的绑定细粒度过高就会产生大量的Watcher,
 *        这会带来内存以及依赖追踪的开销,而细粒度过低会无法精准侦测变化,因此Vue的设计是选择中等细粒度的方案,
 *        在组件级别进行push侦测的方式,也就是那套响应式系统,通常我们会第一时间侦测到发生变化的组件,
 *        然后在组件内部进行Virtual Dom Diff获取更加具体的差异,而Virtual Dom Diff则是pull操作,
 *        Vue是push+pull结合的方式进行变化侦测的
 *     2.vue3.0优化虚拟dom
 *        虽然 Vue 能够保证触发更新的组件最小化，但在单个组件内部依然需要遍历该组件的整个 vdom 树。
          vue3.0将 vdom 更新性能由与模版整体大小相关提升为与动态内容的数量相关
      
 */
